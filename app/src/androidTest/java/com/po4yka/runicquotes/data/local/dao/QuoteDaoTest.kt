package com.po4yka.runicquotes.data.local.dao

import android.content.Context
import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.po4yka.runicquotes.data.local.RunicQuotesDatabase
import com.po4yka.runicquotes.data.local.entity.QuoteEntity
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.test.runTest
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertNotEquals
import org.junit.Assert.assertNotNull
import org.junit.Assert.assertNull
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

/**
 * Instrumented tests for QuoteDao.
 * Tests actual database operations on an Android device/emulator.
 *
 * These tests verify:
 * - CRUD operations
 * - Flow emissions
 * - Query correctness
 * - Data integrity
 */
@RunWith(AndroidJUnit4::class)
class QuoteDaoTest {

    private lateinit var database: RunicQuotesDatabase
    private lateinit var quoteDao: QuoteDao

    private val testQuote1 = QuoteEntity(
        id = 1,
        textLatin = "Test quote 1",
        author = "Author 1",
        runicElder = "ᛏᛖᛋᛏ",
        runicYounger = "ᛏᛖᛋᛏ",
        runicCirth = "\uE088\uE0C9\uE09C\uE088",
        isUserCreated = false,
        isFavorite = false,
        createdAt = 1000L
    )

    private val testQuote2 = QuoteEntity(
        id = 2,
        textLatin = "Test quote 2",
        author = "Author 2",
        runicElder = "ᚦᛖᛋᛏ",
        runicYounger = null,
        runicCirth = null,
        isUserCreated = true,
        isFavorite = true,
        createdAt = 2000L
    )

    private val testQuote3 = QuoteEntity(
        id = 3,
        textLatin = "Test quote 3",
        author = "Author 3",
        runicElder = "ᚹᛟᚱᛞ",
        runicYounger = null,
        runicCirth = null,
        isUserCreated = false,
        isFavorite = true,
        createdAt = 3000L
    )

    @Before
    fun setUp() {
        val context = ApplicationProvider.getApplicationContext<Context>()

        // Create in-memory database for testing
        database = Room.inMemoryDatabaseBuilder(
            context,
            RunicQuotesDatabase::class.java
        ).allowMainThreadQueries() // For testing purposes
            .build()

        quoteDao = database.quoteDao()
    }

    @After
    fun tearDown() {
        database.close()
    }

    // ==================== Insert Tests ====================

    @Test
    fun insertQuote_insertsSuccessfully() = runTest {
        // When: Inserting a quote
        val id = quoteDao.insert(testQuote1)

        // Then: ID is returned and quote is in database
        assertTrue(id > 0)
        val retrieved = quoteDao.getById(testQuote1.id)
        assertNotNull(retrieved)
        assertEquals(testQuote1.textLatin, retrieved?.textLatin)
    }

    @Test
    fun insertAll_insertsMultipleQuotes() = runTest {
        // When: Inserting multiple quotes
        quoteDao.insertAll(listOf(testQuote1, testQuote2, testQuote3))

        // Then: All quotes are in database
        val count = quoteDao.getCount()
        assertEquals(3, count)
    }

    @Test
    fun insert_withAutoGeneratedId_generatesId() = runTest {
        // Given: Quote with id = 0 (auto-generate)
        val quote = testQuote1.copy(id = 0)

        // When: Inserting quote
        val id = quoteDao.insert(quote)

        // Then: ID is auto-generated
        assertTrue(id > 0)
        val retrieved = quoteDao.getById(id)
        assertNotNull(retrieved)
    }

    @Test
    fun insert_replacesOnConflict() = runTest {
        // Given: Quote already in database
        quoteDao.insert(testQuote1)

        // When: Inserting quote with same ID but different text
        val updated = testQuote1.copy(textLatin = "Updated text")
        quoteDao.insert(updated)

        // Then: Quote is replaced
        val retrieved = quoteDao.getById(testQuote1.id)
        assertEquals("Updated text", retrieved?.textLatin)
    }

    // ==================== Retrieve Tests ====================

    @Test
    fun getById_retrievesCorrectQuote() = runTest {
        // Given: Quotes in database
        quoteDao.insertAll(listOf(testQuote1, testQuote2, testQuote3))

        // When: Getting quote by ID
        val quote = quoteDao.getById(2)

        // Then: Correct quote is retrieved
        assertNotNull(quote)
        assertEquals(testQuote2.textLatin, quote?.textLatin)
        assertEquals(testQuote2.author, quote?.author)
    }

    @Test
    fun getById_returnsNull_whenQuoteDoesNotExist() = runTest {
        // When: Getting non-existent quote
        val quote = quoteDao.getById(999)

        // Then: Returns null
        assertNull(quote)
    }

    @Test
    fun getAll_returnsAllQuotes_orderedByCreatedAtDesc() = runTest {
        // Given: Quotes with different creation times
        quoteDao.insertAll(listOf(testQuote1, testQuote2, testQuote3))

        // When: Getting all quotes
        val quotes = quoteDao.getAll()

        // Then: All quotes returned in descending order by createdAt
        assertEquals(3, quotes.size)
        assertEquals(3000L, quotes[0].createdAt) // Most recent first
        assertEquals(2000L, quotes[1].createdAt)
        assertEquals(1000L, quotes[2].createdAt)
    }

    @Test
    fun getAll_returnsEmptyList_whenDatabaseIsEmpty() = runTest {
        // When: Getting all quotes from empty database
        val quotes = quoteDao.getAll()

        // Then: Empty list is returned
        assertTrue(quotes.isEmpty())
    }

    @Test
    fun getRandom_returnsQuote_whenQuotesExist() = runTest {
        // Given: Quotes in database
        quoteDao.insertAll(listOf(testQuote1, testQuote2, testQuote3))

        // When: Getting random quote
        val quote = quoteDao.getRandom()

        // Then: A quote is returned
        assertNotNull(quote)
        assertTrue(quote?.id in listOf(1L, 2L, 3L))
    }

    @Test
    fun getRandom_returnsNull_whenDatabaseIsEmpty() = runTest {
        // When: Getting random quote from empty database
        val quote = quoteDao.getRandom()

        // Then: Returns null
        assertNull(quote)
    }

    @Test
    fun getCount_returnsCorrectCount() = runTest {
        // Given: Three quotes in database
        quoteDao.insertAll(listOf(testQuote1, testQuote2, testQuote3))

        // When: Getting count
        val count = quoteDao.getCount()

        // Then: Correct count is returned
        assertEquals(3, count)
    }

    @Test
    fun getCount_returnsZero_whenDatabaseIsEmpty() = runTest {
        // When: Getting count from empty database
        val count = quoteDao.getCount()

        // Then: Zero is returned
        assertEquals(0, count)
    }

    // ==================== Flow Tests ====================

    @Test
    fun getAllAsFlow_emitsAllQuotes() = runTest {
        // Given: Quotes in database
        quoteDao.insertAll(listOf(testQuote1, testQuote2, testQuote3))

        // When: Observing flow
        val quotes = quoteDao.getAllAsFlow().first()

        // Then: All quotes are emitted
        assertEquals(3, quotes.size)
    }

    @Test
    fun getAllAsFlow_emitsUpdates_whenQuotesChange() = runTest {
        // Given: Initial quotes
        quoteDao.insertAll(listOf(testQuote1, testQuote2))

        // When: Adding a new quote
        quoteDao.insert(testQuote3)

        // Then: Flow emits updated list
        val quotes = quoteDao.getAllAsFlow().first()
        assertEquals(3, quotes.size)
    }

    @Test
    fun getUserQuotesFlow_emitsOnlyUserCreatedQuotes() = runTest {
        // Given: Mix of user and system quotes
        quoteDao.insertAll(listOf(testQuote1, testQuote2, testQuote3))

        // When: Observing user quotes flow
        val userQuotes = quoteDao.getUserQuotesFlow().first()

        // Then: Only user-created quotes are emitted
        assertEquals(1, userQuotes.size)
        assertTrue(userQuotes.all { it.isUserCreated })
        assertEquals(testQuote2.id, userQuotes[0].id)
    }

    @Test
    fun getUserQuotesFlow_emitsEmptyList_whenNoUserQuotes() = runTest {
        // Given: Only system quotes
        quoteDao.insertAll(listOf(testQuote1, testQuote3))

        // When: Observing user quotes flow
        val userQuotes = quoteDao.getUserQuotesFlow().first()

        // Then: Empty list is emitted
        assertTrue(userQuotes.isEmpty())
    }

    @Test
    fun getFavoritesFlow_emitsOnlyFavoriteQuotes() = runTest {
        // Given: Mix of favorite and non-favorite quotes
        quoteDao.insertAll(listOf(testQuote1, testQuote2, testQuote3))

        // When: Observing favorites flow
        val favorites = quoteDao.getFavoritesFlow().first()

        // Then: Only favorites are emitted
        assertEquals(2, favorites.size)
        assertTrue(favorites.all { it.isFavorite })
    }

    @Test
    fun getFavoritesFlow_emitsEmptyList_whenNoFavorites() = runTest {
        // Given: Only non-favorite quotes
        quoteDao.insert(testQuote1)

        // When: Observing favorites flow
        val favorites = quoteDao.getFavoritesFlow().first()

        // Then: Empty list is emitted
        assertTrue(favorites.isEmpty())
    }

    @Test
    fun getFavorites_returnsOnlyFavoriteQuotes() = runTest {
        // Given: Mix of favorite and non-favorite quotes
        quoteDao.insertAll(listOf(testQuote1, testQuote2, testQuote3))

        // When: Getting favorites
        val favorites = quoteDao.getFavorites()

        // Then: Only favorites are returned
        assertEquals(2, favorites.size)
        assertTrue(favorites.all { it.isFavorite })
    }

    // ==================== Update Tests ====================

    @Test
    fun update_updatesExistingQuote() = runTest {
        // Given: Quote in database
        quoteDao.insert(testQuote1)

        // When: Updating quote
        val updated = testQuote1.copy(textLatin = "Updated text", author = "Updated author")
        quoteDao.update(updated)

        // Then: Quote is updated
        val retrieved = quoteDao.getById(testQuote1.id)
        assertEquals("Updated text", retrieved?.textLatin)
        assertEquals("Updated author", retrieved?.author)
    }

    @Test
    fun updateFavoriteStatus_togglesFavorite() = runTest {
        // Given: Non-favorite quote
        quoteDao.insert(testQuote1)
        assertFalse(quoteDao.getById(testQuote1.id)!!.isFavorite)

        // When: Toggling favorite to true
        quoteDao.updateFavoriteStatus(testQuote1.id, true)

        // Then: Quote is marked as favorite
        val retrieved = quoteDao.getById(testQuote1.id)
        assertTrue(retrieved!!.isFavorite)

        // When: Toggling favorite to false
        quoteDao.updateFavoriteStatus(testQuote1.id, false)

        // Then: Quote is no longer favorite
        val retrievedAgain = quoteDao.getById(testQuote1.id)
        assertFalse(retrievedAgain!!.isFavorite)
    }

    @Test
    fun updateFavoriteStatus_updatesOnlySpecifiedQuote() = runTest {
        // Given: Multiple quotes
        quoteDao.insertAll(listOf(testQuote1, testQuote2))

        // When: Updating favorite status of one quote
        quoteDao.updateFavoriteStatus(testQuote1.id, true)

        // Then: Only that quote is updated
        assertTrue(quoteDao.getById(testQuote1.id)!!.isFavorite)
        assertTrue(quoteDao.getById(testQuote2.id)!!.isFavorite) // Was already true
    }

    // ==================== Delete Tests ====================

    @Test
    fun delete_removesQuote() = runTest {
        // Given: Quote in database
        quoteDao.insert(testQuote1)
        assertEquals(1, quoteDao.getCount())

        // When: Deleting quote
        quoteDao.delete(testQuote1)

        // Then: Quote is removed
        assertEquals(0, quoteDao.getCount())
        assertNull(quoteDao.getById(testQuote1.id))
    }

    @Test
    fun deleteAll_removesAllQuotes() = runTest {
        // Given: Multiple quotes
        quoteDao.insertAll(listOf(testQuote1, testQuote2, testQuote3))
        assertEquals(3, quoteDao.getCount())

        // When: Deleting all
        quoteDao.deleteAll()

        // Then: Database is empty
        assertEquals(0, quoteDao.getCount())
    }

    @Test
    fun deleteUserQuote_deletesOnlyUserCreatedQuote() = runTest {
        // Given: User-created quote
        quoteDao.insert(testQuote2)

        // When: Deleting user quote
        quoteDao.deleteUserQuote(testQuote2.id)

        // Then: Quote is deleted
        assertNull(quoteDao.getById(testQuote2.id))
    }

    @Test
    fun deleteUserQuote_doesNotDeleteSystemQuote() = runTest {
        // Given: System quote
        quoteDao.insert(testQuote1)

        // When: Attempting to delete as user quote
        quoteDao.deleteUserQuote(testQuote1.id)

        // Then: Quote is not deleted (because it's not user-created)
        assertNotNull(quoteDao.getById(testQuote1.id))
    }

    @Test
    fun deleteUserQuote_deletesOnlySpecifiedQuote() = runTest {
        // Given: Multiple user quotes
        val userQuote1 = testQuote2.copy(id = 10)
        val userQuote2 = testQuote2.copy(id = 11)
        quoteDao.insertAll(listOf(userQuote1, userQuote2))

        // When: Deleting one user quote
        quoteDao.deleteUserQuote(10)

        // Then: Only that quote is deleted
        assertNull(quoteDao.getById(10))
        assertNotNull(quoteDao.getById(11))
    }

    // ==================== Data Integrity Tests ====================

    @Test
    fun quote_preservesAllFields() = runTest {
        // Given: Quote with all fields populated
        val completeQuote = QuoteEntity(
            id = 100,
            textLatin = "Complete quote",
            author = "Complete Author",
            runicElder = "ᛖᛚᛞᛖᚱ",
            runicYounger = "ᚤᛟᚢᛜᛖᚱ",
            runicCirth = "\uE0C9\uE0C8\uE0A0\uE088",
            isUserCreated = true,
            isFavorite = true,
            createdAt = 12345L
        )

        // When: Inserting and retrieving
        quoteDao.insert(completeQuote)
        val retrieved = quoteDao.getById(100)

        // Then: All fields are preserved
        assertNotNull(retrieved)
        assertEquals(completeQuote.id, retrieved?.id)
        assertEquals(completeQuote.textLatin, retrieved?.textLatin)
        assertEquals(completeQuote.author, retrieved?.author)
        assertEquals(completeQuote.runicElder, retrieved?.runicElder)
        assertEquals(completeQuote.runicYounger, retrieved?.runicYounger)
        assertEquals(completeQuote.runicCirth, retrieved?.runicCirth)
        assertEquals(completeQuote.isUserCreated, retrieved?.isUserCreated)
        assertEquals(completeQuote.isFavorite, retrieved?.isFavorite)
        assertEquals(completeQuote.createdAt, retrieved?.createdAt)
    }

    @Test
    fun quote_handlesNullRunicFields() = runTest {
        // Given: Quote with null runic fields
        val quoteWithNulls = testQuote2.copy(
            runicElder = null,
            runicYounger = null,
            runicCirth = null
        )

        // When: Inserting and retrieving
        quoteDao.insert(quoteWithNulls)
        val retrieved = quoteDao.getById(quoteWithNulls.id)

        // Then: Null fields are preserved
        assertNotNull(retrieved)
        assertNull(retrieved?.runicElder)
        assertNull(retrieved?.runicYounger)
        assertNull(retrieved?.runicCirth)
    }

    @Test
    fun quote_handlesUnicodeCharacters() = runTest {
        // Given: Quote with unicode characters
        val unicodeQuote = testQuote1.copy(
            textLatin = "Café naïve résumé 日本語",
            author = "Ñoño Müller"
        )

        // When: Inserting and retrieving
        quoteDao.insert(unicodeQuote)
        val retrieved = quoteDao.getById(unicodeQuote.id)

        // Then: Unicode is preserved
        assertEquals("Café naïve résumé 日本語", retrieved?.textLatin)
        assertEquals("Ñoño Müller", retrieved?.author)
    }

    @Test
    fun quote_handlesLongText() = runTest {
        // Given: Quote with very long text
        val longText = "A".repeat(10000)
        val longQuote = testQuote1.copy(textLatin = longText)

        // When: Inserting and retrieving
        quoteDao.insert(longQuote)
        val retrieved = quoteDao.getById(longQuote.id)

        // Then: Long text is preserved
        assertEquals(longText, retrieved?.textLatin)
    }

    // ==================== Edge Cases ====================

    @Test
    fun emptyStringFields_areHandledCorrectly() = runTest {
        // Given: Quote with empty strings
        val emptyQuote = testQuote1.copy(
            textLatin = "",
            author = ""
        )

        // When: Inserting and retrieving
        quoteDao.insert(emptyQuote)
        val retrieved = quoteDao.getById(emptyQuote.id)

        // Then: Empty strings are preserved
        assertEquals("", retrieved?.textLatin)
        assertEquals("", retrieved?.author)
    }

    @Test
    fun specialCharacters_areHandledCorrectly() = runTest {
        // Given: Quote with special characters
        val specialQuote = testQuote1.copy(
            textLatin = "Quote with 'quotes', \"double quotes\", and symbols: !@#$%^&*()",
            author = "Author-Name_123"
        )

        // When: Inserting and retrieving
        quoteDao.insert(specialQuote)
        val retrieved = quoteDao.getById(specialQuote.id)

        // Then: Special characters are preserved
        assertEquals(specialQuote.textLatin, retrieved?.textLatin)
        assertEquals(specialQuote.author, retrieved?.author)
    }

    @Test
    fun multipleConcurrentInserts_allSucceed() = runTest {
        // When: Inserting multiple quotes with auto-generated IDs
        val quote1 = testQuote1.copy(id = 0)
        val quote2 = testQuote2.copy(id = 0)
        val quote3 = testQuote3.copy(id = 0)

        val id1 = quoteDao.insert(quote1)
        val id2 = quoteDao.insert(quote2)
        val id3 = quoteDao.insert(quote3)

        // Then: All get unique IDs
        assertNotEquals(id1, id2)
        assertNotEquals(id2, id3)
        assertNotEquals(id1, id3)
        assertEquals(3, quoteDao.getCount())
    }
}
